# Lab3 实验报告

## 编译选项

本人直接编程在单个文件 server.c 里。

要向树莓派环境编译时，需要添加 `-O3` `--std=c99`  `-lpthread` 选项，后两个是为了支持类似 C++ 的 for 循环写法，以及 pthread 安全。

例如，在本人机器上使用 Lab1 所用的交叉编译工具时，编译指令为 :
```
arm-linux-gnueabihf-gcc server.c -o server -O3 --std=c99 -lpthread
```

至于运行的话
```
./server
```

## 实验设计

### “合理的假定“

虽说我们可以通过一切形式构造出长度超过 1M 字符数的请求内容，但是对于那些我们可以解析并确认合法（既不是 `500 Internal Server Error` 也不是 `404 Not Found`）的 ”请求“，应当是：
- 开头的前五个字符必定是 `GET /` 。否则，或者 HTTP 方法不是 `GET` ，或者是不以 / 开头的非法路径（当然也包括没有路径）。
- 路径长度不超过 4096 个字符。否则，即使我们将其完整解析，调用 `open` 等函数打开文件时，系统也无法识别它。
- 后面的 HTTP 请求协议，Host 等是被本实验 ”确保“ 无误的。

也就意味着，虽然 HTTP 协议标准需要我们读完整的请求内容，但我们需要保存的只是前几千个字符（本人保存了 8192 个），后面的循环读取并丢弃即可。

### 必做：解析和检验 HTTP 头

鉴于 `read` 和 `write` 偶尔出现的，不能读全或写全指定字节数的情况，本人的代码中都包含了诸多 ”循环读取“ 的行为。

解析判定包括如下几个部分：
- 请求内容至多读并存储到 8192 字节，超过 8192 字节之后的部分被另一个循环读取丢弃掉。若请求内容总数不足 5 字节，或前5个字节不是 `GET /`，或在 8192 字节内找不到分割 PATH 字段的第二个空格，则判定为 ”500“ 情形。
- 在 PATH 字段内，判定该路径将会到达的层次，中途任何一个时刻企图到达 ”根目录“ （server 所在目录）上层目录的行为（比如 `/123/../../`）被认定非法并返回 ”500“
- 将 PATH 字段的前一个分割空格替换为 '.' 字符，后一个空格替换为 '\0'，将从'.' 开始的字符串作为路径传递给 `open` 和 `stat` 函数（无视，或者任凭在这个字符串区间内仍有其他 '\0' 字符出现的情况），若 `open` 失败，返回 ”404“；再若 `stat` 返回的状态表明文件不是常规文件（`!S_ISREG(fstatus->st_mode)`），则返回 ”500“。
- 若一切非法情况都没有发生，则获得目标文件的文件描述符

### 必做：实现读取请求文件内容

虽然使用 `read` 和 `write` 以及必要的循环，可以做到完整读取并写出请求文件的内容，但是 `sendfile` 函数的效率更高——本人只是更改为这个函数就得到了近两成的效率提升。

`Content-Length` 响应头在解析请求的时候就已经可以用 `stat` 获得，或者对于 404 和 500 的情形，值为 0 。

### 必做：实现错误和异常处理

关于错误和异常处理的实现有一些共性，是基于：
- 全部的文件描述符被本人设定为阻塞式，故大多数时候（如对 `read` `write`）不会出现返回 `EAGAIN || EWOULDBLOCK` 的情况。
- 本人设置了 `signal(SIGPIPE, SIG_IGN)` 。故以防任何可以返回 `EINTR` 的函数被它打断，当函数返回此错误时，会继续执行未完成的工作而非停止。

此外，一切函数出错时（如 `malloc` 失败等），会在输出错误信息，退出当前函数或整个程序前，将关闭应当在该函数关闭的文件描述符、释放内存。

当然还有如下两个函数的特殊情况：

#### read 读不满

考量 `read` 不能读够给定字符数的情况，`read` 的返回值除非是 `EINTR` 以外的错误，否则继续读取直到满（或者，比如说对解析请求，读到 `\r\n\r\n` 时终止）。

#### write 写不足 或 写错误

定义一个额外的函数
```C
size_t write_stable(int fd, const void *buf, size_t count)；
```
将不断向 fd 写 buf 所在内存开始的 count 个字符，直到调用 `write` 函数返回除 `EINTR` 以外的错误—— `write_stable` 函数返回 0，否则返回已写字节数。

### 必做：多进程，多线程；选做：epoll，线程池

由于多进程不足以充分并发，多进程+多线程开销加大，多进程 epoll + 多线程处理请求会出现许多关于文件描述符传参错乱的问题等，本人最后使用的是 主进程接收请求 + 多线程多 epoll 接收任务 的模式。

对于主进程：
- 创建 MAX_THREAD_NUM 个进程（本人定义为 16），并为每个进程创建 epoll。
- 监听请求 socket，当 `accept` 成功时，以 `EPOLLEN | EPOLLONESHOT` 模式，将其依次轮流添加到 16 个进程的 epoll 列表（第 1 个请求给第 1 个线程，第 8 个请求给第 8 个线程，第 18 个 请求给第 2 个线程，......）。

对于每个线程：
- 通过自己的线程 id，唯一地获得自己所拥有的 epoll 列表。
- `epoll_wait` 该列表并处理其得到的任务。
